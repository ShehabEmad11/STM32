#include "STD_TYPES.h"
#include "BIT_MATH.h"
#include "Timer2to5_interface.h"
#include "Timer2to5_private.h"


/*With 7 prescaler, we got min time of 1Ms and max Time of 65535Ms=65ms*/
extern void MTIMR2to5_voidInit(u8 copy_u8TimerNumber, u16 copy_u16Prescaler)
{
	if(copy_u8TimerNumber>=2  && copy_u8TimerNumber<=5)
	{
		/*Update Timer number to match with array in private file*/
		copy_u8TimerNumber=copy_u8TimerNumber-2;
	}
	else
	{
		/*Wrong timer input*/
		asm("nop");
		return;
	}
	
	 /*Use internal clock as clock source for the timer::
	 1-disable slave mode: by clearing bits0:2 (SMS) in (TIMx_SMCR)
	 2-use bits 0,4 in TIMx_CR1 to choose counting direction and enable clock
	 */
	 TIMx[copy_u8TimerNumber]->SMCR=0x0000;
	/*Set the prescaler value to divide the clock*/
	 TIMx[copy_u8TimerNumber]->PSC=copy_u16Prescaler;

	/*depending on the auto-reload preload enable bit (ARPE) in TIMx_CR1 register. 
	 The update event is sent when the counter reaches the overflow (or underflow when downcounting)
	  and if the UDIS bit equals 0 in the TIMx_CR1 register. It can also be generated by software. */
	/*Set Bit 7 ARPE: Auto-reload preload enable*/
	/*Clear Bits 6:5 (CMS) in (TIMx_CR1): Center-aligned mode selection to use Edge-aligned mode.
   	The counter counts up or down depending on the direction bit_4(DIR).*/
	/*Clear Bit 4 in(TIMx_CR1) to use counter as upcounter*/
	/*Clear Bit 3 in(TIMx_CR1) to not stop counter at next update event*/
	/*Set Bit 2 (URS) in (TIMx_CR1) Only counter overflow/underflow generates an update interrupt or DMA request*/
	/*Clear BIT 1 (UDIS)in (TIMx_CR1) to Enable Update Event UEV*/ 
	/*Set/Clr Bit 0 (CEN) in(TIMx_CR1) to enable/Disable counter CEN*/
	TIMx[copy_u8TimerNumber]->CR1=0x0084;

	/*TIMx_CR2 not used by me now*/
	/*TIMx slave mode control register (TIMx_SMCR) not used by me now*/
	/*TIMx DMA/Interrupt enable register (TIMx_DIER)*/
}

extern void MTIMR2to5_voidSetBusyWait(u8 copy_u8TimerNumber,u16 copy_u16Delay)
{
	if(copy_u8TimerNumber>=2  && copy_u8TimerNumber<=5)
	{
		/*Update Timer number to match with array in private file*/
		copy_u8TimerNumber=copy_u8TimerNumber-2;
	}
	else
	{
		/*Wrong timer input*/
		asm("nop");
		return ;
	}
	/* Load ticks to load register */
	TIMx[copy_u8TimerNumber]->ARR=copy_u16Delay;

	/*Force update event without setting update interrupt flag by setting BIT0_UG in EGR while URS_Bit2 in
	 TIMx_CR1 is set */
	SET_BIT(TIMx[copy_u8TimerNumber]->CR1,2);
	SET_BIT(TIMx[copy_u8TimerNumber]->EGR,0);

	/* Start Counter */
	SET_BIT(TIMx[copy_u8TimerNumber]->CR1,0);

	/*When an update event occurs, all the registers are updated and the update flag (UIF bit in
	  TIMx_SR register) is set (depending on the URS bit):*/
	/* Wait till Update Interrupt flag (UIF) is raised */

	while( (GET_BIT(TIMx[copy_u8TimerNumber]->SR,0)) == 0);

	/*Clear Flag*/
	CLR_BIT(TIMx[copy_u8TimerNumber]->SR,0);

	/*Disable Counter */
	CLR_BIT(TIMx[copy_u8TimerNumber]->CR1,0);
	/*Reset Auto Reload Register*/
	TIMx[copy_u8TimerNumber]-> ARR = 0;			
}



extern void MTIMR2to5_voidSetTimerSingle(u8 copy_u8TimerNumber,u16 copy_u16Delay)
{
	if(copy_u8TimerNumber>=2  && copy_u8TimerNumber<=5)
	{
		/*Update Timer number to match with array in private file*/
		copy_u8TimerNumber=copy_u8TimerNumber-2;
	}
	else
	{
		/*Wrong timer input*/
		asm("nop");
		return ;
	}
	/* Load ticks to load register */
	TIMx[copy_u8TimerNumber]->ARR=copy_u16Delay;

	/*Force update event without setting update interrupt flag by setting BIT0_UG in EGR while URS_Bit2 in
	 TIMx_CR1 is set */
	SET_BIT(TIMx[copy_u8TimerNumber]->CR1,2);
	SET_BIT(TIMx[copy_u8TimerNumber]->EGR,0);

	/*Enable Update Interrupt*/
	SET_BIT(TIMx[copy_u8TimerNumber]->DIER,0);

	/* Start Counter */
	SET_BIT(TIMx[copy_u8TimerNumber]->CR1,0);
}

void TIM2_IRQHandler(void)
{
	/*Disable Update Interrupt*/
	CLR_BIT(TIMx[0]->DIER,0);
	/*Clear Flag*/
	CLR_BIT(TIMx[0]->SR,0);
	/*Disable Counter */
	CLR_BIT(TIMx[0]->CR1,0);
	/*Reset Auto Reload Register*/
	TIMx[0]-> ARR = 0;
}
