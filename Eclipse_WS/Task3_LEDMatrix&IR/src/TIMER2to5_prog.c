/*****************************************/
/* Author  :  Shehab Emad  */
/* Version :  Ver2.0                     */
/* Date    : 12/1/2022             		 */
/*****************************************/


#include "STD_TYPES.h"
#include "BIT_MATH.h"
#include "Timer2to5_interface.h"
#include "Timer2to5_private.h"
#include "TIMER2to5_config.h"


typedef struct
{
	uint32 AlarmVal_Ms;
	uint32 TimePassed_Ms;
	uint8  IsAlarmSet;
	uint8  IsAlarmFired;
}TIMxContext_t;

//Context0 ---->Used by BSW
//Context1 ---->Used by APP
static TIMxContext_t TIMx_astrAlarmContext[4][TIMR2to5_MAXCONTEXTS];

/* Define static global Variable for interval mode */
static u8 TIMx_u8ArrModeOfInterval[4];

/* Declare Array of Ptr to Callback static Global Variable */
static void(*TIMx_ArrPtrCallBack[4])(void)={NULL,NULL,NULL,NULL};

const uint32 TIMx_ArrBaseTick[4]={TIM2_BASETICK_Ms,TIM3_BASETICK_Ms,TIM4_BASETICK_Ms,TIM5_BASETICK_Ms};

/*With 7 prescaler, we got min time of 1Ms and max Time of 65535Ms=65ms*/
extern void MTIMR2to5_voidInit(u8 copy_u8TimerNumber, u16 copy_u16Prescaler)
{
	u8 ContextIterator;

	if(copy_u8TimerNumber>MTIMER_5)
		return;

	/*Update Timer number to match with array in private file*/
	//copy_u8TimerNumber=copy_u8TimerNumber-2;
	
	/*Initialize Context Array*/

	for(ContextIterator=0;ContextIterator<TIMR2to5_MAXCONTEXTS;ContextIterator++)
	{
		TIMx_astrAlarmContext[copy_u8TimerNumber][ContextIterator].AlarmVal_Ms=0;
		TIMx_astrAlarmContext[copy_u8TimerNumber][ContextIterator].TimePassed_Ms=0;
		TIMx_astrAlarmContext[copy_u8TimerNumber][ContextIterator].IsAlarmSet=FALSE;
		TIMx_astrAlarmContext[copy_u8TimerNumber][ContextIterator].IsAlarmFired=FALSE;
	}

	 /*Use internal clock as clock source for the timer::
	 1-disable slave mode: by clearing bits0:2 (SMS) in (TIMx_SMCR)
	 2-use bits 0,4 in TIMx_CR1 to choose counting direction and enable clock
	 */
	 TIMx[copy_u8TimerNumber]->SMCR=0x0000;
	/*Set the prescaler value to divide the clock*/
	 TIMx[copy_u8TimerNumber]->PSC=copy_u16Prescaler;

	/*depending on the auto-reload preload enable bit (ARPE) in TIMx_CR1 register. 
	 The update event is sent when the counter reaches the overflow (or underflow when downcounting)
	  and if the UDIS bit equals 0 in the TIMx_CR1 register. It can also be generated by software. */
	/*Set Bit 7 ARPE: Auto-reload preload enable see page 372*/
	/*Clear Bits 6:5 (CMS) in (TIMx_CR1): Center-aligned mode selection to use Edge-aligned mode.
   	The counter counts up or down depending on the direction bit_4(DIR).*/
	/*Clear Bit 4 in(TIMx_CR1) to use counter as upcounter*/
	/*Clear Bit 3 in(TIMx_CR1) to not stop counter at next update event*/
	/*Set Bit 2 (URS) in (TIMx_CR1) Only counter overflow/underflow generates an update interrupt or DMA request*/
	/*Clear BIT 1 (UDIS)in (TIMx_CR1) to Enable Update Event UEV*/ 
	/*Set/Clr Bit 0 (CEN) in(TIMx_CR1) to enable/Disable counter CEN*/
	TIMx[copy_u8TimerNumber]->CR1=0x0084;

	/*TIMx_CR2 not used by me now*/
	/*TIMx slave mode control register (TIMx_SMCR) not used by me now*/
	/*TIMx DMA/Interrupt enable register (TIMx_DIER)*/
}

extern void MTIMR2to5_voidSetBusyWait(u8 copy_u8TimerNumber,u16 copy_u16Delay)
{
	if(copy_u8TimerNumber>MTIMER_5)
		return;

	/*Update Timer number to match with array in private file*/
	//copy_u8TimerNumber=copy_u8TimerNumber-2;

	/* Load ticks to load register */
	TIMx[copy_u8TimerNumber]->ARR=copy_u16Delay;

	/*Force update event without setting update interrupt flag by setting BIT0_UG in EGR while URS_Bit2 in
	 TIMx_CR1 is set */
	/*Bit 0 UG: Update generation
	This bit can be set by software, it is automatically cleared by hardware.
	0: No action
	1: Re-initialize the counter and generates an update of the registers. Note that the prescaler
	counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if
	the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload
	value (TIMx_ARR) if DIR=1 (downcounting).*/
	SET_BIT(TIMx[copy_u8TimerNumber]->CR1,2);
	SET_BIT(TIMx[copy_u8TimerNumber]->EGR,0);

	/* Start Counter */
	SET_BIT(TIMx[copy_u8TimerNumber]->CR1,0);

	/*When an update event occurs, all the registers are updated and the update flag (UIF bit in
	  TIMx_SR register) is set (depending on the URS bit):*/
	/* Wait till Update Interrupt flag (UIF) is raised */

	while( (GET_BIT(TIMx[copy_u8TimerNumber]->SR,0)) == 0);

	/*Clear Flag*/
	CLR_BIT(TIMx[copy_u8TimerNumber]->SR,0);

	/*Disable Counter */
	CLR_BIT(TIMx[copy_u8TimerNumber]->CR1,0);
	/*Reset Auto Reload Register*/
	TIMx[copy_u8TimerNumber]-> ARR = 0;			
}



extern void MTIMR2to5_voidSetTimerSingle(u8 copy_u8TimerNumber,u16 copy_u16Interval,void (*copy_Ptr2CallBack)(void))
{
	if(copy_u8TimerNumber>MTIMER_5)
		return;

	/*Update Timer number to match with array in private file*/
	//copy_u8TimerNumber=copy_u8TimerNumber-2;

	/* Save CallBack */
	TIMx_ArrPtrCallBack[copy_u8TimerNumber] = copy_Ptr2CallBack;

	/* Set Mode to Single */
	TIMx_u8ArrModeOfInterval[copy_u8TimerNumber] = TIMx_SINGLE_INTERVAL;

	/* Load ticks to load register */
	TIMx[copy_u8TimerNumber]->ARR=copy_u16Interval;


	/*Force update event without setting update interrupt flag by setting BIT0_UG in EGR while URS_Bit2 in
	 TIMx_CR1 is set */
	/*Bit 0 UG: Update generation
	This bit can be set by software, it is automatically cleared by hardware.
	0: No action
	1: Re-initialize the counter and generates an update of the registers. Note that the prescaler
	counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if
	the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload
	value (TIMx_ARR) if DIR=1 (downcounting).*/
	SET_BIT(TIMx[copy_u8TimerNumber]->CR1,2);
	SET_BIT(TIMx[copy_u8TimerNumber]->EGR,0);

	/*Enable Update Interrupt*/
	SET_BIT(TIMx[copy_u8TimerNumber]->DIER,0);

	/* Start Counter */
	SET_BIT(TIMx[copy_u8TimerNumber]->CR1,0);
}



extern void MTIMR2to5_voidSetTimerPeriodic(u8 copy_u8TimerNumber,u16 copy_u16PeriodMs,void (*copy_Ptr2CallBack)(void))
{
	if(copy_u8TimerNumber>MTIMER_5)
		return;

	/*Update Timer number to match with array in private file*/
	//copy_u8TimerNumber=copy_u8TimerNumber-2;

	/* Save CallBack */
	TIMx_ArrPtrCallBack[copy_u8TimerNumber] = copy_Ptr2CallBack;

	/* Set Mode to Periodic*/
	TIMx_u8ArrModeOfInterval[copy_u8TimerNumber] = TIMx_PERIODIC_INTERVAL;

	/* Load ticks to load register */
	TIMx[copy_u8TimerNumber]->ARR=copy_u16PeriodMs;


	/*Force update event without setting update interrupt flag by setting BIT0_UG in EGR while URS_Bit2 in
	 TIMx_CR1 is set */
	/*Bit 0 UG: Update generation
	This bit can be set by software, it is automatically cleared by hardware.
	0: No action
	1: Re-initialize the counter and generates an update of the registers. Note that the prescaler
	counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if
	the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload
	value (TIMx_ARR) if DIR=1 (downcounting).*/
	SET_BIT(TIMx[copy_u8TimerNumber]->CR1,2);
	SET_BIT(TIMx[copy_u8TimerNumber]->EGR,0);

	/*Enable Update Interrupt*/
	SET_BIT(TIMx[copy_u8TimerNumber]->DIER,0);

	/* Start Counter */
	SET_BIT(TIMx[copy_u8TimerNumber]->CR1,0);
}

extern uint8 MTIMR2to5_u8GetElapsedTime(uint8 copy_u8TimerNumber, uint16* copy_ptru16ElapsedTime)
{
	if(copy_u8TimerNumber>MTIMER_5)
		return E_NOT_OK;

	//DownCounter state not implemented yet
	if(TIMx[copy_u8TimerNumber]->ARR < TIMx[copy_u8TimerNumber]->CNT )
		return E_NOT_OK;

	*copy_ptru16ElapsedTime = TIMx[copy_u8TimerNumber]->CNT ;

	return E_OK;
}

extern void MTIMR2to5_voidStopInterval(uint8 copy_u8TimerNumber)
{
	if(copy_u8TimerNumber>MTIMER_5)
		return;

	/*Disable Update Interrupt*/
	CLR_BIT(TIMx[0]->DIER,0);
	/*Clear Flag*/
	CLR_BIT(TIMx[0]->SR,0);
	/*Disable Counter */
	CLR_BIT(TIMx[0]->CR1,0);
	/*Reset Auto Reload Register*/
	TIMx[0]-> ARR = 0;
	/*Reset Counter Register (no need as it will be reset when next Set-interval called)*/
	TIMx[0]-> CNT = 0;

	/*Reset callBack*/
	TIMx_ArrPtrCallBack[0]=NULL;
}


/*There is some error margin due to use of TIMx periodic ISR
 1- If we set very short Periodic Timer, this will cause overhead delay which is not accounted for.
  *for example if Timer is 10 Ms Period while we set alarm for 10,000,000Ms(10seconds)
 	---->for this alarm the ISR will executed 1,000,000 time, and if we assumed that ISR execution time
   is only 1Ms this will cause overhead delay of 1,000,000Ms (1 second) which is not accounted for
 2- if we set very long periodic TImer, the following will happen:
     2.1)this will cause resolution of 1sec as minimum resolution
     2.2)first ISR of each alarm will miss a portion of its time
   *for example if Timer is 1000,000 Ms(1sec) Period:
     2.1)we will not be able to set any Alarm with value less than 1 sec
     2.2)lets say we started periodic timer of (1s period) at t=0, while we started to set alarm
         at t=400ms	then when first alarm's ISR comes it will be only 600ms passed, which will
         make alarm miss a value of 400ms
 Conclusion: trade off balance must be made when choosing tick value*/

extern void MTIMR2to5_voidSetAlarm_Ms(u8 copy_u8TimerNumber,u8 copy_u8ContextNumber,u32 copy_u32MsVal)
{
	uint16 local_u16ElapsedTime=0;

	if(copy_u8ContextNumber>=TIMR2to5_MAXCONTEXTS)
		return;
	if(copy_u8TimerNumber>MTIMER_5)
		return ;

	/*Update Timer number to match with array in private file*/
	//copy_u8TimerNumber=copy_u8TimerNumber-2;

	/*Check the time already passed from current TIMx ISR*/
	if(E_OK != MTIMR2to5_u8GetElapsedTime(copy_u8TimerNumber, &local_u16ElapsedTime))
		return;

	/*If more than 50% of current TIMx ISR has passed then we need to more one extra ISR */
	if(local_u16ElapsedTime > (TIMx_ArrBaseTick[copy_u8TimerNumber] / 2ul))
	{
		copy_u32MsVal += TIMx_ArrBaseTick[copy_u8TimerNumber];
	}


	TIMx_astrAlarmContext[copy_u8TimerNumber][copy_u8ContextNumber].AlarmVal_Ms=copy_u32MsVal;
	TIMx_astrAlarmContext[copy_u8TimerNumber][copy_u8ContextNumber].TimePassed_Ms=0;
	TIMx_astrAlarmContext[copy_u8TimerNumber][copy_u8ContextNumber].IsAlarmFired=FALSE;
	TIMx_astrAlarmContext[copy_u8TimerNumber][copy_u8ContextNumber].IsAlarmSet=TRUE;
}



extern void MTIM2_voidCountAndFireTIM2Alarms(void)
{
	u8 ContextIterator;

	for(ContextIterator=0;ContextIterator<TIMR2to5_MAXCONTEXTS;ContextIterator++)
	{
		if(	TIMx_astrAlarmContext[MTIMER_2][ContextIterator].IsAlarmSet==TRUE
		&&  TIMx_astrAlarmContext[MTIMER_2][ContextIterator].IsAlarmFired==FALSE 	)
		{
			TIMx_astrAlarmContext[MTIMER_2][ContextIterator].TimePassed_Ms += TIM2_BASETICK_Ms;

			if(TIMx_astrAlarmContext[MTIMER_2][ContextIterator].TimePassed_Ms
			>= TIMx_astrAlarmContext[MTIMER_2][ContextIterator].AlarmVal_Ms )
			{
				TIMx_astrAlarmContext[MTIMER_2][ContextIterator].IsAlarmFired=TRUE;
				TIMx_astrAlarmContext[MTIMER_2][ContextIterator].IsAlarmSet=FALSE;
			}
		}
	}
}


extern u8 TIMx_u8IsAlarmFired(u8 copy_u8TimerNumber,u8 copy_u8ContextNumber,u8* copy_Ptr2u8AlarmState)
{
	if(copy_u8ContextNumber>=TIMR2to5_MAXCONTEXTS)
		return E_NOT_OK;
	if(copy_u8TimerNumber>MTIMER_5)
		return E_NOT_OK;

	/*Update Timer number to match with array in private file*/
	//copy_u8TimerNumber=copy_u8TimerNumber-2;

	*copy_Ptr2u8AlarmState= TIMx_astrAlarmContext[copy_u8TimerNumber][copy_u8ContextNumber].IsAlarmFired;

	return E_OK;
}

extern u8 TIMx_u8ClrAlarmFired(u8 copy_u8TimerNumber,u8 copy_u8ContextNumber)
{
	if(copy_u8ContextNumber>=TIMR2to5_MAXCONTEXTS)
		return E_NOT_OK;
	if(copy_u8TimerNumber>MTIMER_5)
		return E_NOT_OK;

	/*Update Timer number to match with array in private file*/
	//copy_u8TimerNumber=copy_u8TimerNumber-2;

	TIMx_astrAlarmContext[copy_u8TimerNumber][copy_u8ContextNumber].IsAlarmFired=FALSE;

	return E_OK;
}



void TIM2_IRQHandler(void)
{
	if (TIMx_u8ArrModeOfInterval[0] == TIMx_SINGLE_INTERVAL)
	{
		/*Disable Update Interrupt*/
		CLR_BIT(TIMx[0]->DIER,0);
		/*Disable Counter */
		CLR_BIT(TIMx[0]->CR1,0);
		/*Reset Auto Reload Register*/
		TIMx[0]-> ARR = 0;

		/*Reset callBack*/
		TIMx_ArrPtrCallBack[0]=NULL;
	}

	/*Clear Flag*/
	CLR_BIT(TIMx[0]->SR,0);

	/*Call Callback  */
	if(NULL != TIMx_ArrPtrCallBack[0])
		TIMx_ArrPtrCallBack[0]();
}
